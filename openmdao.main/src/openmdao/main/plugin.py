import sys
import os.path
import webbrowser
import tempfile
import tarfile
import shutil

import urllib2
import json
import pprint
import StringIO
from ConfigParser import SafeConfigParser
from argparse import ArgumentParser
from subprocess import call, check_call
import fnmatch

from ordereddict import OrderedDict

from setuptools import find_packages
from pkg_resources import WorkingSet, Requirement

from openmdao.main.factorymanager import get_available_types, plugin_groups
from openmdao.util.fileutil import build_directory, find_files, get_ancestor_dir
from openmdao.util.dep import PythonSourceTreeAnalyser
from openmdao.util.dumpdistmeta import get_metadata
from openmdao.util.git import download_github_tar
from openmdao.util.view_docs import view_docs
from openmdao.main.pkg_res_factory import plugin_groups
from openmdao.main import __version__

#from sphinx.setup_command import BuildDoc
import sphinx

# There are a number of string templates that are used to produce various
# files within the plugin distribution. These templates are stored in the
# _templates dict, with the key being the name of the file that the 
# template corresponds to.
_templates = {}

# This is the template for the file that Sphinx uses to configure itself.
# It's intended to match the conf.py for the OpenMDAO docs, so if those 
# change, this may need to be updated.
_templates['conf.py'] = '''

# This file is autogenerated during plugin quickstart and overwritten during
# plugin makedist. DO NOT CHANGE IT if you plan to use plugin makedist to package
# distribution.

# -*- coding: utf-8 -*-
#
# This file is execfile()d with the current directory set to its containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed automatically).
#

import sys, os

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 
              'sphinx.ext.doctest', 'sphinx.ext.todo','openmdao.util.doctools', 
              'sphinx.ext.viewcode'
      ]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'%(name)s'
copyright = u'%(copyright)s'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '%(version)s'
#The short version is the one that shows up in the file when you use /version/.
# The full version, including alpha/beta/rc tags.
release = '%(release)s'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%%B %%d, %%Y'

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = %(static_path)s

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%%b %%d, %%Y'

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

html_theme = "default"

# using these theme options will make the docs share a consistent
# look with the OpenMDAO docs
html_theme_options = {
     "headtextcolor": "darkred",
     "headbgcolor": "gainsboro",
     "headfont": "Arial",
     "relbarbgcolor": "black",
     "relbartextcolor": "white",
     "relbarlinkcolor": "white",
     "sidebarbgcolor": "gainsboro",
     "sidebartextcolor": "darkred",
     "sidebarlinkcolor": "black",
     "footerbgcolor": "gainsboro",
     "footertextcolor": "darkred",
     "textcolor": "black",
     "codebgcolor": "#FFFFCC",
     "linkcolor": "darkred",
     "codebgcolor": "#ffffcc",
    }

todo_include_todos = True

# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/dev': None}

autodoc_member_order = 'groupwise'

'''

# template for the top level file in the Sphinx docs for the plugin
_templates['index.rst'] = """

%(title_marker)s
%(name)s Documentation
%(title_marker)s

Contents:

.. toctree::
   :maxdepth: 2
    
   usage
   srcdocs
   pkgdocs

"""

# template for the file where the user may add specific usage documentation
# for the plugin
_templates['usage.rst'] = """

===========
Usage Guide
===========

No usage information has been provided for this plugin. Consult the
:ref:`%(name)s_src_label` section for more detail.

"""

# template for the file that packages and install the plugin using setuptools
_templates['setup.py'] = '''

#
# This file is autogenerated during plugin quickstart and overwritten during
# plugin makedist. DO NOT CHANGE IT if you plan to use plugin makedist to update 
# the distribution.
#

from setuptools import setup, find_packages

kwargs = %(setup_options)s

setup(**kwargs)

'''

# template for the file that tells setuptools/distutils what extra data
# files to include in the distribution for the plugin
_templates['MANIFEST.in'] = """

graft src/%(name)s/sphinx_build/html
recursive-include src/%(name)s/test *.py

"""

# template for the README.txt file.
_templates['README.txt'] = """

README.txt file for %(name)s.

To view the Sphinx documentation for this distribution, type:

plugin docs %(name)s

"""

# template for the setup configuration file, where all of the user
# supplied metadata is located.  This file may be hand edited by the 
# plugin developer.
_templates['setup.cfg'] = """

[metadata]
name = %(name)s
version = %(version)s
summary = 
description-file = README.txt
keywords = openmdao
home-page = 
download-url = 
author = 
author-email = 
maintainer = 
maintainer-email = 
license = 
classifier = Intended Audience :: Science/Research
    Topic :: Scientific/Engineering

requires-dist = openmdao.main
provides-dist = 
obsoletes-dist = 
requires-python = 
    >=2.6
    <3.0
requires-externals = 
project-url = 

[openmdao]
copyright =
static_path = [ '_static' ]
"""


# This dict contains string templates corresponding to skeleton python source files
# for each of the recognized plugin types.  
_class_templates = {}

# TODO: These should be updated to reflect best practices because most plugin
# developers will start with these when they create new plugins.

_class_templates['openmdao.component'] = '''
__all__ = ['%(classname)s']

from openmdao.main.api import Component
from openmdao.lib.datatypes.api import Float


# Make sure that your class has some kind of docstring. Otherwise
# the descriptions for your variables won't show up in the
# source ducumentation.
class %(classname)s(Component):
    """
    """
    # declare inputs and outputs here, for example:
    #x = Float(0.0, iotype='in', desc='description for x')
    #y = Float(0.0, iotype='out', desc='description for y')

    def execute(self):
        """ do your calculations here """
        pass
        
'''

_class_templates['openmdao.driver'] = '''
__all__ = ['%(classname)s']

from openmdao.main.api import Driver
from openmdao.main.hasparameters import HasParameters
from openmdao.util.decorators import add_delegate
from openmdao.lib.datatypes.api import Float

# Make sure that your class has some kind of docstring. Otherwise
# the descriptions for your variables won't show up in the
# source ducumentation.
#@add_delegate(HasParameters)  # uncomment this to add parameter handling
class %(classname)s(Driver):
    """
    """

    # declare inputs and outputs here, for example:
    #x = Float(0.0, iotype='in', desc='description for x')
    #y = Float(0.0, iotype='out', desc='description for y')
    
    def start_iteration(self):
        super(%(classname)s, self).start_iteration()

    def continue_iteration(self):
        return super(%(classname)s, self).continue_iteration()
    
    def pre_iteration(self):
        super(%(classname)s, self).pre_iteration()
        
    def run_iteration(self):
        super(%(classname)s, self).run_iteration()

    def post_iteration(self):
        super(%(classname)s, self).post_iteration()

'''

_class_templates['openmdao.variable'] = '''
__all__ = ['%(classname)s']

from openmdao.main.variable import Variable

class %(classname)s(Variable):

    #def __init__(self, default_value = ???, **metadata):
    #    super(%(classname)s, self).__init__(default_value=default_value,
    #                                        **metadata)

    def validate(self, object, name, value):
        pass
        # insert validation code here
        
        # in the event of an error, call
        # self.error(object, name, value)
'''

_class_templates['openmdao.surrogatemodel'] = '''

__all__ = ['%(classname)s']

from enthought.traits.api import HasTraits

from openmdao.main.interfaces import implements, ISurrogate

class %(classname)s(HasTraits):

    implements(ISurrogate)
    
    def train(self,X,Y):
        """Train the surrogate model with the given set of inputs and outputs."""
        
    def predict(self,new_x):
        """Calculates a predicted value of the response based on the current
        trained model for the supplied list of inputs.        
'''

def _get_srcdocs(destdir, name):
    startdir = os.getcwd()
    srcdir = os.path.join(destdir,'src')
    if os.path.exists(srcdir):
        os.chdir(srcdir)
        try:
            srcmods = _get_src_modules('.')
        finally:
            os.chdir(startdir)
    else:
        srcmods = ["%s.%s" % (name,name)]

    contents = [
        """
.. _%s_src_label:


====================
Source Documentation
====================
        
        """ % name
        ]
    
    for mod in sorted(srcmods):
        pkgfile = '%s.py' % mod
        pkg, dot, name = mod.rpartition('.')
        pyfile = '%s.py' % name
        underline = '-'*len(pyfile)
        contents.append("""
.. index:: %s

.. _%s:

%s
%s

.. automodule:: %s
   :members:
   :undoc-members:
   :show-inheritance:
    
        """ % (pyfile, pkgfile, pyfile, underline, mod))

    return ''.join(contents)


def _get_pkgdocs(cfg):
    """Return a string in reST format that contains the metadata
    for the package.
    
    cfg: ConfigParser
        ConfigParser object used to read the setup.cfg file
    """
    lines = ['\n',
             '================\n',
             'Package Metadata\n',
             '================\n',
             '\n']

    metadata = {}
    if cfg.has_section('metadata'):
        metadata.update(dict([item for item in cfg.items('metadata')]))
    if cfg.has_section('openmdao'):
        metadata.update(dict([item for item in cfg.items('openmdao')]))

    tuplist = list(metadata.items())
    tuplist.sort()
    for key,value in tuplist:
        if value.strip():
            if '\n' in value:
                lines.append("- **%s**:: \n\n" % key)
                for v in [vv.strip() for vv in value.split('\n')]:
                    if v:
                        lines.append("    %s\n" % v)
                lines.append('\n')
            elif value != 'UNKNOWN':
                lines.append("- **%s:** %s\n\n" % (key, value))
        
    return ''.join(lines)


def _get_setup_options(distdir, metadata):
    # a set of names of variables that are supposed to be lists
    lists = set([
        'keywords',
        'install_requires',
        'packages',
        'classifiers',
        ])
    
    # mapping of new metadata names to old ones
    mapping = {
        'name': 'name',
        'version': 'version',
        'keywords': 'keywords',
        'summary': 'description',
        'description': 'long_description',
        'home-page': 'url',
        'download-url': 'download_url',
        'author': 'author',
        'author-email': 'author_email',
        'maintainer': 'maintainer',
        'maintainer-email': 'maintainer_email',
        'license': 'license',
        'classifier': 'classifiers',
        'requires-dist': 'install_requires',
        'entry_points': 'entry_points',
        #'py_modules': 'py_modules',
        'packages': 'packages',
        }
    
    # populate the package data with sphinx docs
    # we have to list all of the files because setuptools doesn't
    # handle nested directories very well
    pkgdir = os.path.join(distdir, 'src', metadata['name'])
    plen = len(pkgdir)+1
    sphinxdir = os.path.join(pkgdir, 'sphinx_build', 'html')
    testdir = os.path.join(pkgdir, 'test')
    pkglist = list(find_files(sphinxdir))
    pkglist.extend(list(find_files(testdir, exclude="*.py[co]")))
    pkglist = [p[plen:] for p in pkglist]
    setup_options = {
        #'packages': [metadata['name']],
        'package_data': { 
            metadata['name']: pkglist #[
            #'sphinx_build/html/*.*',
            #'sphinx_build/html/_modules/*',
            #'sphinx_build/html/_sources/*',
            #'sphinx_build/html/_static/*',
            #] 
        },
        'package_dir': {'': 'src'},
        'zip_safe': False,
        'include_package_data': True,
    }
    
    for key,val in metadata.items():
        if key in mapping:
            if isinstance(val, basestring):
                if mapping[key] in lists:
                    val = [p.strip() for p in val.split('\n') if p.strip()]
                else:
                    val = val.strip()
            setup_options[mapping[key]] = val

    return setup_options


def _pretty(obj):
    sio = StringIO.StringIO()
    pprint.pprint(obj, sio)
    return sio.getvalue()


def _get_py_files(distdir):
    def _pred(fname):
        parts = fname.split(os.sep)
        if parts[-1] in ['setup.py','__init__.py'] or 'test' in parts:
            return False
        return fname.endswith('.py')
    return list(find_files(distdir, _pred))
        

def _get_src_modules(topdir):
    topdir = os.path.abspath(os.path.expandvars(os.path.expanduser(topdir)))
    pyfiles = _get_py_files(topdir)
    noexts = [os.path.splitext(f)[0] for f in pyfiles]
    rel = [f[len(topdir)+1:] for f in noexts]
    return ['.'.join(f.split(os.sep)) for f in rel]
    

def _get_template_options(distdir, cfg, **kwargs):
    if cfg.has_section('metadata'):
        metadata = dict([item for item in cfg.items('metadata')])
    else:
        metadata = {}
    if cfg.has_section('openmdao'):
        openmdao_metadata = dict([item for item in cfg.items('openmdao')])
    else:
        openmdao_metadata = {}
        
    if 'static_path' not in openmdao_metadata:
        openmdao_metadata['static_path'] = ''

    if 'packages' in kwargs:
        metadata['packages'] = kwargs['packages']
    else:
        metadata['packages'] = [metadata['name']]

    setup_options = _get_setup_options(distdir, metadata)
    
    template_options = {
        'copyright': '',
        'summary': '',
        'setup_options': _pretty(setup_options)
    }
    
    template_options.update(setup_options)
    template_options.update(openmdao_metadata)
    template_options.update(kwargs)
    
    name = template_options['name']
    version = template_options['version']
    
    template_options.setdefault('release', version)
    template_options.setdefault('title_marker', 
                                '='*(len(name)+len(' Documentation')))
        
    return template_options



test_template = """

import unittest


class %(classname)sTestCase(unittest.TestCase):

    def setUp(self):
        pass
        
    def tearDown(self):
        pass
        
    # add some tests here...
    
    #def test_%(classname)s(self):
        #pass
        
if __name__ == "__main__":
    unittest.main()
    
"""


def plugin_quickstart(options):
    """A command line script (plugin quickstart) points to this.  It generates a
    directory structure for an openmdao plugin package along with Sphinx docs.
    
    usage: plugin quickstart <dist_name> [-v <version>] [-d <dest_dir>] [-g <plugin_group>] [-c class_name]
    
    """

    name = options.dist_name
    if options.classname:
        classname = options.classname
    else:
        classname = "%s%s" % ((name.upper())[0], name[1:])
    version = options.version
    
    options.dest = os.path.abspath(os.path.expandvars(os.path.expanduser(options.dest)))
    if not options.group.startswith('openmdao.'):
        options.group = 'openmdao.'+options.group

    startdir = os.getcwd()
    try:
        os.chdir(options.dest)
        
        if os.path.exists(name):
            raise OSError("Can't create directory '%s' because it already exists." %
                          os.path.join(options.dest, name))
        
        cfg = SafeConfigParser(dict_type=OrderedDict)
        stream = StringIO.StringIO(_templates['setup.cfg'] % { 'name':name, 
                                                              'version':version })
        cfg.readfp(stream, 'setup.cfg')
        cfgcontents = StringIO.StringIO()
        cfg.write(cfgcontents)
        
        template_options = _get_template_options(os.path.join(options.dest,name),
                                                 cfg, classname=classname)
        
        template_options['srcmod'] = name
    
        dirstruct = {
            name: {
                'setup.py': _templates['setup.py'] % template_options,
                'setup.cfg': cfgcontents.getvalue(),
                'MANIFEST.in': _templates['MANIFEST.in'] % template_options,
                'README.txt': _templates['README.txt'] % template_options,
                'src': {
                    name: {
                        '__init__.py': '', #'from %s import %s\n' % (name,classname),
                        '%s.py' % name: _class_templates[options.group] % template_options,
                        'test': {
                                'test_%s.py' % name: test_template % template_options
                            },
                        },
                    },
                'docs': {
                    'conf.py': _templates['conf.py'] % template_options,
                    'index.rst': _templates['index.rst'] % template_options,
                    'srcdocs.rst': _get_srcdocs(options.dest, name),
                    'pkgdocs.rst': _get_pkgdocs(cfg),
                    'usage.rst': _templates['usage.rst'] % template_options,
                    },
            },
        }

        build_directory(dirstruct)
    
    finally:
        os.chdir(startdir)

        
def _verify_dist_dir(dpath):
    """Try to make sure that the directory we've been pointed to actually
    contains a distribution.
    """
    if not os.path.isdir(dpath):
        raise IOError("directory '%s' does not exist" % dpath)
    
    expected = ['src', 'docs', 'setup.py', 'setup.cfg', 'MANIFEST.in',
                os.path.join('docs','conf.py'),
                os.path.join('docs','index.rst'),
                os.path.join('docs','srcdocs.rst')]
    for f in expected:
        if not os.path.exists(os.path.join(dpath, f)):
            raise IOError("directory '%s' does not contain '%s'" %
                          (dpath, f))

_excl_set = set(['test', 'docs', 'sphinx_build', '_downloads'])
def _exclude_funct(path):
    return len(_excl_set.intersection(path.split(os.sep))) > 0

#
# FIXME: this still needs some work, but for testing purposes it's ok for now
#
def _find_all_plugins(searchdir):
    """Return a dict containing lists of each plugin type found, keyed by
    plugin group name, e.g., openmdao.component, openmdao.variable, etc.
    """
    dct = {}
    modnames = ['openmdao.main', 
                'openmdao.lib.datatypes', 
                'openmdao.lib.components',
                'openmdao.lib.drivers',
                'openmdao.lib.surrogatemodels',
                'openmdao.lib.doegenerators',
                'openmdao.lib.differentiators',
                'openmdao.lib.optproblems',
                'openmdao.lib.casehandlers',
                'openmdao.lib.architectures']
    
    modules = []
    for mod in modnames:
        try:
            __import__(mod)
        except ImportError:
            print 'skipping import of %s' % mod
        else:
            modules.append(sys.modules[mod])
            
    dirs = [os.path.dirname(m.__file__) for m in modules]+[searchdir]
    psta = PythonSourceTreeAnalyser(dirs, exclude=_exclude_funct)
    
    for key, val in plugin_groups.items():
        dct[key] = set(psta.find_inheritors(val))

    return dct

def _get_entry_points(startdir):
    plugins = _find_all_plugins(startdir)
    entrypoints = StringIO.StringIO()
    for key,val in plugins.items():
        epts = []
        for v in val:
            if v.startswith('openmdao.'):
                continue
            mod,cname = v.rsplit('.', 1)
            epts.append('%s.%s=%s:%s' % (mod,cname,mod,cname))
        if epts:
            entrypoints.write("\n[%s]\n" % key)
            for ept in epts:
                entrypoints.write("%s\n" % ept)
    
    return entrypoints.getvalue()

def plugin_makedist(options):
    """A command line script (plugin makedist) points to this.  It creates a 
    source distribution containing Sphinx documentation for the specified
    distribution directory.  If no directory is specified, the current directory
    is assumed.
    
    usage: plugin makedist [dist_dir_path]
    
    """
    
    options.dist_dir_path = os.path.abspath(os.path.expandvars(os.path.expanduser(options.dist_dir_path)))

    _verify_dist_dir(options.dist_dir_path)

    startdir = os.getcwd()
    os.chdir(options.dist_dir_path)
    
    try:
        plugin_build_docs(options)
        
        cfg = SafeConfigParser(dict_type=OrderedDict)
        cfg.readfp(open('setup.cfg', 'r'), 'setup.cfg')
            
        print "collecting entry point information..."
        cfg.set('metadata', 'entry_points', _get_entry_points('src'))
        
        template_options = _get_template_options(options.dist_dir_path, cfg,
                                                 packages=find_packages('src'))

        dirstruct = {
            'setup.py': _templates['setup.py'] % template_options,
            }
        
        name = cfg.get('metadata', 'name')
        version = cfg.get('metadata', 'version')
        
        if sys.platform == 'win32':
            disttar = "%s-%s.zip" % (name, version)
        else:
            disttar = "%s-%s.tar.gz" % (name, version)
        disttarpath = os.path.join(startdir, disttar)
        if os.path.exists(disttarpath):
            sys.stderr.write("ERROR: distribution %s already exists.\n" % disttarpath)
            sys.exit(-1)
        
        build_directory(dirstruct, force=True)

        cmdargs = [sys.executable, 'setup.py', 'sdist', '-d', startdir]
        retcode = call(cmdargs)
        if retcode:
            cmd = ' '.join(cmdargs)
            sys.stderr.write("\nERROR: command '%s' returned error code: %s\n" % (cmd,retcode))
    finally:
        os.chdir(startdir)

    if os.path.exists(disttar):
        print "Created distribution %s" % disttar
    else:
        sys.stderr.write("\nERROR: failed to make distribution %s" % disttar)

def plugin_docs(options):
    """A command line script (plugin docs) points to this. It brings up
    the Sphinx documentation for the named plugin in a browser.
    """
    if options.plugin_dist_name is None:
        view_docs(options.browser)
    else:
        _plugin_docs(options.plugin_dist_name, options.browser)
        
        
def _plugin_docs(plugin_name, browser=None):
    """This brings up the Sphinx docs for the named plugin using the
    specified browser.  The plugin must be importable in the current 
    environment.
    
    plugin_name: str
        Name of the plugin distribution, module, or class.
        
    browser: str (optional)
        Name of the browser (according to the webbrowser library) to
        use to view the plugin docs.  If none is specified, the platform
        default browser will be used.
    """
    parts = plugin_name.split('.')
    
    if len(parts) == 1: # assume it's a class name and try to find unambiguous module
        modname = None
        # loop over available types to find a class name that matches
        for name, version in get_available_types():
            mname, cname = name.rsplit('.',1)
            if cname == plugin_name:
                if modname and modname != mname:
                    raise RuntimeError("Can't determine module for class '%s' unambiguously. found in %s" %
                                       (cname, [mname, modname]))
                modname = mname
                parts = modname.split('.')
   
        if modname is None: # didn't find a class, so assume plugin_name is a dist name
            parts = [plugin_name, plugin_name]
        
    for i in range(len(parts)-1):
        mname = '.'.join(parts[:len(parts)-i])
        try:
            __import__(mname)
            mod = sys.modules[mname]
            modname = mname
            break
        except ImportError:
            pass
    else:
        raise RuntimeError("Can't locate package/module '%s'" % plugin_name)
    
    if modname.startswith('openmdao.'): # lookup in builtin docs
        fparts = mod.__file__.split(os.sep)
        pkg = '.'.join(modname.split('.')[:2])
        anchorpath = '/'.join(['srcdocs', 'packages','%s.html#module-%s' % (pkg, modname)])
        if any([p.endswith('.egg') and p.startswith('openmdao.') for p in fparts]): 
            # this is a release version, so use online docs
            url = '/'.join(['http://openmdao.org/releases/%s/docs' % __version__, anchorpath])
        else:  # it's a developer version, so use locally built docs
            htmldir = os.path.join(get_ancestor_dir(sys.executable, 3), 'docs', 
                                   '_build', 'html')
            if not os.path.isfile(os.path.join(htmldir,'index.html')): #make sure the local docs are built
                print "local docs not found.\nbuilding them now...\n"
                check_call(['openmdao', 'build_docs'])
            url = 'file://'+os.path.join(htmldir, anchorpath)
            url = url.replace('\\', '/')
    else:
        url = os.path.join(os.path.dirname(os.path.abspath(mod.__file__)),
                           'sphinx_build', 'html', 'index.html')
    
    wb = webbrowser.get(browser)
    wb.open(url)


def plugin_install(options):
    """A command line script (plugin install) points to this. It installs
    the specified plugin distribution into the current environment.
    
    """
    # Interact with github
    if options.github:
        # Get plugin from github.
        
        #FIXME: this should support all valid version syntax (>=, <=, etc.)
        pieces = options.dist_name.split('==')
        name = pieces[0]
        
        # User has specified version using easy_install style ("plugin==version")
        if len(pieces) > 1:
            version = pieces[1]
            
        # Get most recent version from our tag list
        else:
            url = 'https://api.github.com/repos/OpenMDAO-Plugins/%s/tags' % name
    
            try:
                resp = urllib2.urlopen(url)
            except urllib2.HTTPError:
                print "\nERROR: plugin named not found in OpenMDAO-Plugins"
                exit()
                
            for line in resp.fp:
                text = json.loads(line)

                tags = []
                for item in text:
                    tags.append(item['name'])
                
            tags.sort(key=lambda s: map(int, s.split('.')))
            version = tags[-1]
            
        url = 'https://nodeload.github.com/OpenMDAO-Plugins/%s/tarball/%s' % (name, version)
        print url
        
        build_docs_and_install(name, version, findlinks=options.findlinks)
        
    else: # Install plugin from local file or directory
    
        develop = False
        if not options.dist_name:
            print "installing distribution from current directory as a 'develop' egg"
            develop = True
        
        if develop:
            cmdargs = [sys.executable, 'setup.py', 'develop', '-N']
        else:
            cmdargs = ['easy_install', '-f', options.findlinks, options.dist_name]
            
        cmd = ' '.join(cmdargs)
        retcode = call(cmdargs)
        if retcode:
            sys.stderr.write("\nERROR: command '%s' returned error code: %s\n" % (cmd,retcode))
            sys.exit(-1)
            
    if not sys.platform.startswith('win'):
        update_libpath(options)  # make sure LD_LIBRARY_PATH is updated if necessary in activate script
    
        
def update_libpath(options=None):
    """Find all of the shared libraries in the current virtual environment and modify
    the activate script to put their directories in LD_LIBRARY_PATH (or its equivalent)
    """
    ldict = {
        'linux2': 'LD_LIBRARY_PATH',
        'linux': 'LD_LIBRARY_PATH',
        'darwin': 'DYLD_LIBRARY_PATH',
        }
    libpathvname = ldict[sys.platform]
    
    if options is None:
        parser = ArgumentParser(description="adds any shared library paths found in the current python environment to %s" % libpathvname)
        parser.usage = "update_libpath [options]"
        options = parser.parse_args()
    
    if libpathvname:
        topdir = os.path.dirname(os.path.dirname(sys.executable))
        bindir = os.path.join(topdir, 'bin')
        pkgdir = os.path.join(topdir, 'lib', 'python%s.%s' % sys.version_info[:2], 
                              'site-packages')
        sofiles = [os.path.abspath(x) for x in find_files(pkgdir,'*.so')]
                      
        final = set()
        for f in sofiles:
            pyf = os.path.splitext(f)[0]+'.py'
            if not os.path.exists(pyf):
                final.add(os.path.dirname(f))
                
        subdict = { 'libpath': libpathvname,
                    'add_on': os.pathsep.join(final)
                    }
                    
        if len(final) > 0:
            activate_lines = [
            '# BEGIN MODIFICATION\n',
            'if [ -z "$%(libpath)s" ] ; then\n',
            '   %(libpath)s=""\n',
            'fi\n',
            '\n',
            '%(libpath)s=$%(libpath)s:%(add_on)s\n',
            'export %(libpath)s\n',
            '# END MODIFICATION\n',
            '\n',
            ]
            absbin = os.path.abspath(bindir)
            activate_fname = os.path.join(absbin, 'activate')
            with open(activate_fname, 'r') as f:
                lines = f.readlines()
                try:
                    idx = lines.index(activate_lines[0])
                    del lines[idx:idx+len(activate_lines)]
                except ValueError:
                    pass
                
                idx = lines.index('export PATH\n')
                lines[idx+2:idx+2] = activate_lines
                
            content = ''.join(lines)
            
            with open(activate_fname, 'w') as f:
                f.write(content % subdict)
                
            print "\nThe 'activate' file has been updated with new values added to %s" % libpathvname
            print "You must deactivate and reactivate your virtual environment for the"
            print "changes to take effect\n"


    
def build_docs_and_install(name, version, findlinks):
    tdir = tempfile.mkdtemp()
    startdir = os.getcwd()
    os.chdir(tdir)
    try:
        tarpath = download_github_tar('OpenMDAO-Plugins', name, version)
        
        # extract the repo tar file
        tar = tarfile.open(tarpath)
        tar.extractall()
        tar.close()
        
        files = os.listdir('.')
        files.remove(os.path.basename(tarpath))
        if len(files) != 1:
            raise RuntimeError("after untarring, found multiple directories: %s" % files)
        
        # build sphinx docs
        check_call(['plugin', 'build_docs', files[0]])
        os.chdir(files[0]) # should be in distrib directory now
        
        # create an sdist so we can query metadata for distrib dependencies
        check_call([sys.executable, 'setup.py', 'sdist', '-d', '.'])
        
        if sys.platform.startswith('win'):
            tars = fnmatch.filter(os.listdir('.'), "*.zip")
        else:
            tars = fnmatch.filter(os.listdir('.'), "*.tar.gz")
        if len(tars) != 1:
            raise RuntimeError("should have found a single archive file, but found %s instead" % tars)

        check_call(['easy_install', '-NZ', tars[0]])
        
        # now install any dependencies
        metadict = get_metadata(tars[0])
        reqs = metadict.get('requires', [])
        done = set()
        
        while reqs:
            r = reqs.pop()
            if r not in done:
                done.add(r)
                ws = WorkingSet()
                req = Requirement.parse(r)
                d = ws.find(req)
                if d is None:
                    check_call(['easy_install', '-NZ', '-f', findlinks, r])
                    d = ws.find(req)
                    if d is None:
                        raise RuntimeError("Couldn't find distribution '%s'" % r)
                    d.activate()
                    dct = get_metadata(d.egg_name().split('-')[0])
                    for new_r in dct.get('requires',[]):
                        reqs.append(new_r)
    finally:
        os.chdir(startdir)
        shutil.rmtree(tdir, ignore_errors=True)

        
def _plugin_build_docs(destdir, cfg):
    """Builds the Sphinx docs for the plugin distribution, assuming it has
    a structure like the one created by plugin quickstart.
    """
    name = cfg.get('metadata', 'name')
    version = cfg.get('metadata', 'version')
    
    path_added = False
    try:
        docdir = os.path.join(destdir, 'docs')
        srcdir = os.path.join(destdir, 'src')
        
        # have to add srcdir to sys.path or autodoc won't find source code
        if srcdir not in sys.path:
            sys.path[0:0] = [srcdir]
            path_added = True
            
        sphinx.main(argv=['','-E','-a','-b', 'html',
                          '-Dversion=%s' % version,
                          '-Drelease=%s' % version,
                          '-d', os.path.join(srcdir, name, 'sphinx_build', 'doctrees'), 
                          docdir, 
                          os.path.join(srcdir, name, 'sphinx_build', 'html')])
    finally:
        if path_added:
            sys.path.remove(srcdir)
    
    
def plugin_build_docs(options):
    """A command line script (plugin build_docs) points to this.  It builds the
    Sphinx documentation for the specified distribution directory.  
    If no directory is specified, the current directory is assumed.
    
    usage: plugin build_docs [dist_dir_path]
    
    """
    if options.dist_dir_path is None:
        options.dist_dir_path = os.getcwd()

    destdir = os.path.abspath(os.path.expandvars(os.path.expanduser(options.dist_dir_path)))

    _verify_dist_dir(destdir)
    cfgfile = os.path.join(destdir, 'setup.cfg')

    cfg = SafeConfigParser(dict_type=OrderedDict)
    cfg.readfp(open(cfgfile, 'r'), cfgfile)
    
    cfg.set('metadata', 'entry_points', 
            _get_entry_points(os.path.join(destdir,'src')))
    
    template_options = _get_template_options(destdir, cfg)

    dirstruct = {
        'docs': {
            'conf.py': _templates['conf.py'] % template_options,
            'pkgdocs.rst': _get_pkgdocs(cfg),
            'srcdocs.rst': _get_srcdocs(destdir, template_options['name']),
            },
        }
    
    build_directory(dirstruct, force=True, topdir=destdir)
    _plugin_build_docs(destdir, cfg)

    
def plugin_list(options):
    if options.github:
        _list_github_plugins()
        return
    
    groups = []
    for g in options.groups:
        if not g.startswith('openmdao.'):
            g = 'openmdao.'+g
        groups.append(g)
        
    show_all = (options.external == options.builtin)
    if show_all:
        title_type = ''
    elif options.external:
        title_type = 'external'
    else:
        title_type = 'built-in'
        
    title_groups = ','.join([g.split('.')[1] for g in groups])
    parts = title_groups.rsplit(',',1)
    if len(parts) > 1:
        title_groups = ' and '.join(parts)
    
    if not groups:
        groups = None
    all_types = get_available_types(groups)
      
    plugins = set()
    for type in all_types:
        if show_all:
            plugins.add((type[0], type[1]))
        else:
            name = type[0].split('.')[0]
            if name == 'openmdao':
                if options.builtin:
                    plugins.add((type[0], type[1]))
            else:
                if options.external:
                    plugins.add((type[0], type[1]))
            
    
    title = "Installed %s %s plugins" % (title_type, title_groups)
    title = title.replace('  ', ' ')
    under = '-'*len(title)
    print ""
    print title
    print under
    print ""
    for plugin in sorted(plugins):
        print plugin[0], plugin[1]
        
    print "\n"

def _list_github_plugins():
    url = 'https://api.github.com/orgs/OpenMDAO-Plugins/repos?type=public'
    
    print "\nAvailable plugin distributions"
    print "==============================\n"
    
    resp = urllib2.urlopen(url)
    for line in resp.fp:
        text = json.loads(line)
        for item in sorted(text):
            print '%20s -- %s' % (item['name'], item['description'])
        print '\n'
        

def _get_plugin_parser():
    """Sets up the plugin arg parser and all of its subcommand parsers."""
    
    top_parser = ArgumentParser()
    subparsers = top_parser.add_subparsers(title='subcommands',
                                           #description='valid subcommands',
                                           #help='additional help'
                                           )
    
    parser = subparsers.add_parser('list', description = "List installed plugins")
    parser.usage = "plugin list [options]"
    parser.add_argument("--github", 
                        help='List plugins in the official Openmdao-Plugins repository on github', 
                        action='store_true')
    parser.add_argument("-b", "--builtin", 
                        help='List all installed plugins that are part of the OpenMDAO distribution', 
                        action='store_true')
    parser.add_argument("-e", "--external", 
                        help='List all installed plugins that are not part of the OpenMDAO distribution', 
                        action='store_true')
    parser.add_argument("-g", "--group", action="append", type=str, dest='groups',
                        default=[], 
                        choices=[p.split('.',1)[1] for p in plugin_groups.keys()],
                        help="specify plugin group")
    parser.set_defaults(func=plugin_list)
    
    
    parser = subparsers.add_parser('install', 
                                   description="install an OpenMDAO plugin into the current environment")
    parser.usage = "plugin install [plugin_distribution] [options]"
    parser.add_argument('dist_name', help='name of plugin distribution (defaults to distrib found in current dir)', 
                        nargs='?')
    parser.add_argument("--github", 
                        help='Find plugin in the official Openmdao-Plugins repository on github', 
                        action='store_true')
    parser.add_argument("-f", "--find-links", action="store", type=str, 
                        dest='findlinks', default='http://openmdao.org/dists',
                        help="URL of find-links server")
    parser.set_defaults(func=plugin_install)
    
    
    parser = subparsers.add_parser('build_docs', 
                                   description="build sphinx doc files for a plugin")
    parser.usage = "plugin build_docs <dist_dir_path>"
    parser.add_argument('dist_dir_path', help='path to distribution source directory')
    parser.set_defaults(func=plugin_build_docs)

    
    parser = subparsers.add_parser('docs', 
                                   description="display docs for a plugin")
    parser.usage = "plugin docs <plugin_dist_name>"
    parser.add_argument('plugin_dist_name', help='name of plugin distribution')
    parser.add_argument("-b", "--browser", action="store", type=str, 
                        dest='browser', choices=webbrowser._browsers.keys(),
                        help="browser name")
    parser.set_defaults(func=plugin_docs)
    
    
    parser = subparsers.add_parser('quickstart',
                                   description="generate some skeleton files for a plugin")
    parser.usage = "plugin quickstart <dist_name> [options]"
    parser.add_argument('dist_name', help='name of distribution')
    parser.add_argument("-v", "--version", action="store", type=str, dest='version', 
                        default='0.1',
                        help="version id of the plugin (defaults to 0.1)")
    parser.add_argument("-c", "--class", action="store", type=str, dest='classname',
                        help="plugin class name")
    parser.add_argument("-d", "--dest", action="store", type=str, dest='dest', 
                        default='.',
                        help="directory where new plugin directory will be created (defaults to current dir)")
    parser.add_argument("-g", "--group", action="store", type=str, dest='group', 
                        default = 'openmdao.component',
                        help="specify plugin group %s (defaults to 'openmdao.component')" % plugin_groups.keys())
    parser.set_defaults(func=plugin_quickstart)
    
    
    parser = subparsers.add_parser('makedist',
                                   description="create a source distribution for a plugin")
    parser.usage = "plugin makedist [dist_dir_path]"
    parser.add_argument('dist_dir_path', nargs='?',
                        default='.',
                        help='directory where plugin distribution is found (defaults to current dir')
    parser.set_defaults(func=plugin_makedist)
    
    return top_parser


def plugin():
    options = _get_plugin_parser().parse_args()
    options.func(options)
    

